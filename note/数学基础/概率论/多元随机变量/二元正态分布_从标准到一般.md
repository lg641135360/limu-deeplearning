### 试验：二元标准正态分布的生成

* 生成各自均值为0，方差为1，随机变量间的协方差为0的二元标准正态分布随机变量X和Y

* 生成5000组样本，并实际观察可视化的结果

```python
mean = np.array([0, 0])  # 均值
conv = np.array([[1, 0], [0, 1]])  # 协方差矩阵

# 生成样本 多元正态分布的
x, y = np.random.multivariate_normal(mean=mean, cov=conv, size=5000).T  # 转置是api需求

# 绘图操作
plt.figure(figsize=(6, 6))  # 设置图片大小
plt.plot(x, y, 'ro', alpha=0.2)
plt.gca().axes.set_xlim(-4, 4)  # 设置x轴上下限
plt.gca().axes.set_ylim(-4, 4)  # 设置y轴上下限
plt.grid(ls='--')
plt.show()
```

![image-20230403214550919](%E4%BA%8C%E5%85%83%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83_%E4%BB%8E%E6%A0%87%E5%87%86%E5%88%B0%E4%B8%80%E8%88%AC.assets/image-20230403214550919.png)

### 从特殊到一般

### 试验： 二元一般正态分布的生成

* 调整参数

* 第一：调整多个随机变量自身的均值
* 第二：调整随机变量自身的**方差**
* 试验：调整随机变量X，Y自身的方差，保留彼此独立的关系，观察样本图像的特征
* 设定随机变量X的方差为4，Y 的方差为0.25 生成3000组样本可视化

```python
mean = np.array([0, 0])
conv_1 = np.array([[1, 0], [0, 1]])

conv_2 = np.array([[4, 0], [0, 0.25]])

# 构造两个不同的正态分布
# 标准正态
x_1, y_1 = np.random.multivariate_normal(mean=mean, cov=conv_1, size=3000).T
x_2, y_2 = np.random.multivariate_normal(mean=mean, cov=conv_2, size=3000).T

# 绘图
plt.figure(figsize=(6, 6))
plt.plot(x_1, y_1, 'ro', alpha=0.05)
plt.plot(x_2, y_2, 'bo', alpha=0.05)

# 设置坐标轴大小
plt.gca().axes.set_xlim(-6, 6)
plt.gca().axes.set_ylim(-6, 6)

# 设置网格线
plt.grid(ls='--')
plt.show()
```

![image-20230403215341030](%E4%BA%8C%E5%85%83%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83_%E4%BB%8E%E6%A0%87%E5%87%86%E5%88%B0%E4%B8%80%E8%88%AC.assets/image-20230403215341030.png)

### 试验：二元一般正态分布的生成

* 第三：调整随机变量之间的协方差
* 试验：保持随机变量各自方差不变，通过改变协方差的值，观察对**随机变量间相关特性**的影响
* 四组二元正态分布 组一：二元标准正态分布
  * 组二：协方差为0.3 
  * 组三：协方差为0.85 
  * 组四：协方差为-0.85

```python
# 使用子图方式进行对比
fig, ax = plt.subplots(2, 2)
mean = np.array([0, 0])

conv_1 = np.array([[1, 0], [0, 1]])
conv_2 = np.array([[1, 0.3], [0.3, 1]])  # 方差不变，只改变协方差
conv_3 = np.array([[1, 0.85], [0.85, 1]])
conv_4 = np.array([[1, -0.85], [-0.85, 1]])

# 获取每组正态分布的3000组样本
x_1, y_1 = np.random.multivariate_normal(mean=mean, cov=conv_1, size=3000).T
x_2, y_2 = np.random.multivariate_normal(mean=mean, cov=conv_2, size=3000).T
x_3, y_3 = np.random.multivariate_normal(mean=mean, cov=conv_3, size=3000).T
x_4, y_4 = np.random.multivariate_normal(mean=mean, cov=conv_4, size=3000).T

# 绘制
ax[0][0].plot(x_1, y_1, 'bo', alpha=0.05)
ax[0][1].plot(x_2, y_2, 'bo', alpha=0.05)
ax[1][0].plot(x_3, y_3, 'bo', alpha=0.05)
ax[1][1].plot(x_4, y_4, 'bo', alpha=0.05)

# 背景网格线
ax[0][0].grid(ls='--')
ax[0][1].grid(ls='--')
ax[1][0].grid(ls='--')
ax[1][1].grid(ls='--')

plt.show()
```



![image-20230403220208132](%E4%BA%8C%E5%85%83%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83_%E4%BB%8E%E6%A0%87%E5%87%86%E5%88%B0%E4%B8%80%E8%88%AC.assets/image-20230403220208132.png)

>协方差值越大，椭圆越窄
>
>为正、负，椭圆方向相反
>
>正相关和负相关