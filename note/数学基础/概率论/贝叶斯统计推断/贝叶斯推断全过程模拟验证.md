### 模拟实验验证

* 写一段模拟抛硬币的程序，我们手上的这枚硬币，正面向上的实际概率为0.62
  * 0.62为要估计的参数
* 生成观测数据：模拟随机抛掷1000次硬币的试验，并旦记录抛掷次数为[5，10，20，100，500，1000]次时，正面出现的次数

* 这个实际概率0.62就是我们需要根据观测数据来估计的末知参数， 并且我们可以用它来和估计值进行对比

### 生成观测数据

* [(2,5), (4, 10), (11,20), (60, 100), (311,500), (614, 1000)]
* 例如(311， 500)表示当实验进行了500次时，正面出现的次数为311次
* 这个试验生成的结果完全是按照伯努利试验随机生成的，你可以重复运行5次该实验，一定会得到完全不同的5组试验结果

```python
import random


# 抛掷一次硬币，出现正面向上的概率为p
def bernoulli_trial(p):  # u服从均匀分布，有p的概率返回1，1-p的概率返回0
    u = random.uniform(0, 1)
    if u <= p:
        return 1
    else:
        return 0


# 模拟抛掷硬币实验（伯努利实验）
def coin_experiments(n_arrary, p):
    y = 0  # 抛掷实验正面向上的次数
    n_max = max(n_arrary)  # [5,10,20,100,500,1000]获取的就是1000
    res = []
    for n in range(1, n_max + 1):
        y = y + bernoulli_trial(p)
        if n in n_arrary:  # 只需要添加[5,10,20,100,500,1000]的正面向上时的次数
            res.append((y, n))
    return res


print(coin_experiments([5, 10, 20, 100, 500, 1000], 0.62))
```

### 选择先验及确定观测数据

* ![image-20230409214643867](%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E5%85%A8%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F%E9%AA%8C%E8%AF%81.assets/image-20230409214643867.png)

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import beta
import seaborn

seaborn.set()

x = np.linspace(0, 1, 100)

# 绘制beta分布为(0.25,0.25)的分布图
plt.plot(x, beta(0.25, 0.25).pdf(x), color='b', label='$\\alpha=0.25,\\beta=0.25$')
# 曲线和横轴之间填充(填充纵轴方向) 填充x轴，起点0，终点pdf曲线
plt.fill_between(x, 0, beta(0.25, 0.25).pdf(x), color='b', alpha=0.25)

plt.plot(x, beta(1, 1).pdf(x), color='g', label='$\\alpha=1,\\beta=1$')
plt.fill_between(x, 0, beta(1, 1).pdf(x), color='g', alpha=0.25)

plt.plot(x, beta(10, 10).pdf(x), color='r', label='$\\alpha=10,\\beta=10$')
plt.fill_between(x, 0, beta(10, 10).pdf(x), color='r', alpha=0.25)

# 绘图设置
plt.gca().axes.set_ylim(0, 10)
plt.legend()  # 图例，图中的每个曲线的名字
plt.show()
```

### 实验结果分析

![image-20230409220329901](%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E5%85%A8%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F%E9%AA%8C%E8%AF%81.assets/image-20230409220329901.png)

![image-20230409220459747](%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD%E5%85%A8%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F%E9%AA%8C%E8%AF%81.assets/image-20230409220459747.png)

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import beta
import seaborn

seaborn.set()

# 参考结果
theta_real = 0.62

# 观测数据
# 抛掷次数
n_array = [5, 10, 20, 100, 500, 1000]
# 正面朝上的次数
y_array = [2, 4, 11, 60, 306, 614]

# beta分布参数列表
beta_params = [(0.25, 0.25), (1, 1), (10, 10)]
x = np.linspace(0, 1, 100)

# 绘制两行三列，共享xy轴
fig, ax = plt.subplots(2, 3, sharex=True, sharey=True)

# 绘制
for i in range(2):
    for j in range(3):
        # 观测数据
        n = n_array[3 * i + j]
        y = y_array[3 * i + j]
        # 计算beta后验分布参数
        # 打包后(0.25,0.25,'b')...
        for (a_prior, b_prior), c in zip(beta_params, ('b', 'r', 'g')):
            a_post = a_prior + y
            b_post = b_prior + n - y
            # 绘制pdf曲线 后验，beta传参为x坐标，两个beta分布参数
            p_theta_given_y = beta.pdf(x, a_post, b_post)
            ax[i, j].plot(x, p_theta_given_y, c)
            ax[i, j].fill_between(x, 0, p_theta_given_y, color=c, alpha=0.25)
        # 画真实值对比
        # 画成一根竖线
        ax[i,j].axvline(theta_real,ymax=0.5,color='k')
        ax[i,j].set_xticks([0,0.2,0.4,0.6,0.8,1]) # 设置x刻度
        ax[i,j].set_title('n={},y={}'.format(n,y))
plt.show()
```

