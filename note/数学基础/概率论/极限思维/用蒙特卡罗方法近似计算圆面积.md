### 用蒙特卡罗方法近似计算圆面积

![image-20230405171549149](%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97%E5%9C%86%E9%9D%A2%E7%A7%AF.assets/image-20230405171549149.png)

### 具体操作方法

![image-20230405171614757](%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97%E5%9C%86%E9%9D%A2%E7%A7%AF.assets/image-20230405171614757.png)

![image-20230405171629187](%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97%E5%9C%86%E9%9D%A2%E7%A7%AF.assets/image-20230405171629187.png)

### 代码

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from scipy.stats import uniform

n = 100000
r = 1.0
o_x, o_y = (0., 0.)  # 圆心横纵坐标 使用元组进行赋值

# 生成100000均匀分布点的横坐标
uniform_x = uniform(o_x - r, 2 * r).rvs(n)  # 起点从圆心-r，跨度则是直径，生成100000个
uniform_y = uniform(o_y - r, 2 * r).rvs(n)

# 距离数组，均匀分布的点与圆心距离，小于半径在圆内
d_array = np.sqrt((uniform_x - o_x) ** 2 + (uniform_y - o_y) ** 2)
# 小于半径 赋1，不然赋为0，这里求和，使用np的方法，小于半径的就是1，加起来所有在园内的点个数
res = sum(np.where(d_array < r, 1, 0))
pi = (res / n) / (r ** 2) * (2 * r) ** 2

fig, ax = plt.subplots(1, 1)
ax.plot(uniform_x, uniform_y, 'ro', alpha=0.2, markersize=0.3)
plt.axis('equal')
circle = Circle(xy = (o_x,o_y),radius=r,alpha=0.5)
ax.add_patch(circle)

print('pi={}'.format(pi))
plt.grid(ls='--')
plt.show()

# res
pi=3.14836
```

![image-20230406173519376](%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%BF%91%E4%BC%BC%E8%AE%A1%E7%AE%97%E5%9C%86%E9%9D%A2%E7%A7%AF.assets/image-20230406173519376.png)